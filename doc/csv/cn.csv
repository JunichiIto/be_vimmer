language,mode,command,description
cn,EX 命令,:!,过滤行，或可通过外部命令执行之
cn,EX 命令,:!!,"重复上次的 "":!"" 命令"
cn,EX 命令,:#,"等同于 "":number"""
cn,EX 命令,:&,"重复上次的 "":substitute"""
cn,EX 命令,:*,执行寄存器的内容
cn,EX 命令,:<,将行左移一个 'shiftwidth'
cn,EX 命令,:=,显示光标所在的行号
cn,EX 命令,:>,将行右移一个 'shiftwidth'
cn,EX 命令,:@,执行寄存器的内容
cn,EX 命令,:@@,"重复上次的 "":@"""
cn,EX 命令,:ab[breviate],输入缩写
cn,EX 命令,:abc[lear],删除所有的缩写
cn,EX 命令,:abo[veleft],使得分割的窗口出现在左侧或者上方
cn,EX 命令,:al[l],为参数列表的每个文件打开一个窗口
cn,EX 命令,:am[enu],为所有模式输入菜单项
cn,EX 命令,:an[oremenu],为所有模式输入菜单项，不会被重新映射
cn,EX 命令,:a[ppend],附加文本
cn,EX 命令,:arga[dd],增加项目到参数列表中
cn,EX 命令,:argd[elete],从参数列表中删除项目
cn,EX 命令,:argdo,在参数列表上的所有项目上执行一个命令
cn,EX 命令,:arge[dit],增加项目到参数列表中并编辑之
cn,EX 命令,:argg[lobal],定义全局参数列表
cn,EX 命令,:argl[ocal],定义本地参数列表
cn,EX 命令,:ar[gs],显示参数列表
cn,EX 命令,:argu[ment],转到参数列表一个指定的文件
cn,EX 命令,:as[cii],显示光标所在的字符的 ascii 值
cn,EX 命令,:aug[roup],选择要用的自动命令组
cn,EX 命令,:aun[menu],删除所有模式下的菜单
cn,EX 命令,:au[tocmd],输入或者显示自动命令
cn,EX 命令,:bad[d],增加缓冲区到缓冲区列表
cn,EX 命令,:ba[ll],为缓冲区列表里的每个缓冲区打开一个窗口
cn,EX 命令,:bd[elete],从缓冲区列表删除缓冲区
cn,EX 命令,:be[have],设置鼠标和选择行为
cn,EX 命令,:bel[owright],使得分割的窗口出现在右侧或者下方
cn,EX 命令,:bf[irst],转到缓冲区列表里的第一个缓冲区
cn,EX 命令,:bl[ast],转到缓冲区列表里的最后一个缓冲区
cn,EX 命令,:bm[odified],转到缓冲区列表里的下一个修改过的缓冲区
cn,EX 命令,:bn[ext],转到缓冲区列表里的下一个缓冲区
cn,EX 命令,:bN[ext],转到缓冲区列表里的上一个缓冲区
cn,EX 命令,:bo[tright],使得分割的窗口出现在最右侧或者下方
cn,EX 命令,:bp[revious],转到缓冲区列表里的上一个缓冲区
cn,EX 命令,:brea[k],跳出 while 循环
cn,EX 命令,:breaka[dd],增加调试器断点
cn,EX 命令,:breakd[el],删除调试器断点
cn,EX 命令,:breakl[ist],列出调试器断点
cn,EX 命令,:br[ewind],转到缓冲区列表里的第一个缓冲区
cn,EX 命令,:bro[wse],使用文件选择对话框
cn,EX 命令,:bufdo,为所有列表内缓冲区执行命令
cn,EX 命令,:b[uffer],转到缓冲区列表里的特定缓冲区
cn,EX 命令,:buffers,列出缓冲区列表里的所有文件
cn,EX 命令,:bun[load],卸载指定的缓冲区
cn,EX 命令,:bw[ipeout],真正删除一个缓冲区
cn,EX 命令,:ca[bbrev],"类似于 "":abbreviate""，但用于命令行模式"
cn,EX 命令,:cabc[lear],清除所有缩写，用于命令行模式
cn,EX 命令,:caddb[uffer],通过缓冲区补充错误
cn,EX 命令,:cad[dexpr],通过表达式补充错误
cn,EX 命令,:caddf[ile],加入错误信息到当前 quickfix 列表
cn,EX 命令,:cal[l],调用函数
cn,EX 命令,:cat[ch],:try 命令的一部分
cn,EX 命令,:cb[uffer],分析错误信息并跳转到第一个
cn,EX 命令,:cc,跳转到特定的错误
cn,EX 命令,:ccl[ose],关闭 quickfix 窗口
cn,EX 命令,:cd,改变目录
cn,EX 命令,:ce[nter],排版行，使其居中对齐
cn,EX 命令,:cex[pr],从表达式里读取错误并跳转到第一个
cn,EX 命令,:cf[ile],读入含有错误信息的文件，并跳转到第一个
cn,EX 命令,:cfir[st],跳转到指定的错误上，缺省为第一个
cn,EX 命令,:cgetb[uffer],从缓冲区里得到错误
cn,EX 命令,:cgete[xpr],从表达实里得到错误
cn,EX 命令,:cg[etfile],读入含有错误信息的文件
cn,EX 命令,:c[hange],替换一行或若干行
cn,EX 命令,:cha[nges],显示修改的列表
cn,EX 命令,:chd[ir],改变当前目录
cn,EX 命令,:che[ckpath],列出包含的头文件
cn,EX 命令,:checkt[ime],检查载入缓冲区的时间标签
cn,EX 命令,:cla[st],跳转到指定的错误上，缺省为最后一个
cn,EX 命令,:cl[ist],列出所有错误
cn,EX 命令,:clo[se],改变当前窗口
cn,EX 命令,:cm[ap],"类似于 "":map""，但用于命令行模式"
cn,EX 命令,:cmapc[lear],清除所有映射，用于命令行模式
cn,EX 命令,:cme[nu],为命令行模式增加菜单
cn,EX 命令,:cnew[er],跳转到下一个较新的错误列表
cn,EX 命令,:cn[ext],跳转到下一个错误
cn,EX 命令,:cN[ext],跳转到上一个错误
cn,EX 命令,:cnf[ile],跳转到下一个文件的第一个错误
cn,EX 命令,:cNf[ile],跳转到前一个文件的最后一个错误
cn,EX 命令,:cnorea[bbrev],"类似于 "":noreabbrev""，但用于命令行模式"
cn,EX 命令,:cno[remap],"类似于 "":noremap""，但用于命令行模式"
cn,EX 命令,:cnoreme[nu],"类似于 "":noremenu""，但用于命令行模式"
cn,EX 命令,:col[der],跳转到上一个较老的错误列表
cn,EX 命令,:colo[rscheme],载入特定的色彩方案
cn,EX 命令,:comc[lear],清除所有用户自定的命令
cn,EX 命令,:com[mand],建立用户自定的命令
cn,EX 命令,:comp[iler],为特定编译器设定选项
cn,EX 命令,:conf[irm],需要确认时，提示用户
cn,EX 命令,:con[tinue],回到 :while 开始处
cn,EX 命令,:cope[n],打开 quickfix 窗口
cn,EX 命令,:co[py],复制行
cn,EX 命令,:cpf[ile],跳转到上一个文件的最后一个错误
cn,EX 命令,:cp[revious],跳转到上一个错误
cn,EX 命令,:cq[uit],退出 Vim，带错误码
cn,EX 命令,:cr[ewind],跳到指定的错误，缺省为第一个
cn,EX 命令,:cs[cope],执行 cscope 命令
cn,EX 命令,:cst[ag],使用 cscope 来跳转到标签上
cn,EX 命令,:cuna[bbrev],"类似于 "":unabbrev""，但用于命令行模式"
cn,EX 命令,:cu[nmap],"类似于 "":unmap""，但用于命令行模式"
cn,EX 命令,:cunme[nu],删除命令行的菜单
cn,EX 命令,:cw[indow],打开或者关闭 quickfix 窗口
cn,EX 命令,:deb[ug],在调试模式执行命令
cn,EX 命令,:debugg[reedy],从正常的输入那里读取调试模式命令
cn,EX 命令,:delc[ommand],删除用户自定的命令
cn,EX 命令,:d[elete],删除行
cn,EX 命令,:delf[unction],删除用户函数
cn,EX 命令,:delm[arks],删除位置标记
cn,EX 命令,:diffg[et],删除当前缓冲区的所有差异
cn,EX 命令,:diffo[ff],关闭 diff 模式
cn,EX 命令,:diffp[atch],应用补丁然后显示差异
cn,EX 命令,:diffpu[t],删除另外一个缓冲区的差异
cn,EX 命令,:diffs[plit],显示和另外一个文件的差异
cn,EX 命令,:diffthis,使得当前窗口成为 diff 窗口
cn,EX 命令,:dif[fupdate],更新 'diff' 缓冲区
cn,EX 命令,:dig[raphs],显示或者输入二合字母
cn,EX 命令,:di[splay],显示寄存器
cn,EX 命令,:dj[ump],跳转到 #define
cn,EX 命令,:dl[ist],列出所有的 #define
cn,EX 命令,:doautoa[ll],在所有载入的缓冲区上应用自动命令
cn,EX 命令,:do[autocmd],在当前缓冲区应用自动命令
cn,EX 命令,:dr[op],跳到编辑某文件的窗口，不成功则在当前窗口编辑之
cn,EX 命令,:ds[earch],列出一个 #define
cn,EX 命令,:dsp[lit],分割窗口并跳转到 #define
cn,EX 命令,:ea[rlier],回到旧的改变，撤销
cn,EX 命令,:ec[ho],回显表达式结果
cn,EX 命令,:echoe[rr],类似于 :echo，如同错误一样显示和使用历史
cn,EX 命令,:echoh[l],为 echo 等命令设置高亮
cn,EX 命令,:echom[sg],等同于 :echo，在历史里放置消息
cn,EX 命令,:echon,等同于 :echo，但不留 <EOL>
cn,EX 命令,:e[dit],编辑文件
cn,EX 命令,:el[se],:if 命令的一部分
cn,EX 命令,:elsei[f],:if 命令的一部分
cn,EX 命令,:em[enu],按名字执行菜单
cn,EX 命令,:endfo[r],结束最近的 :for
cn,EX 命令,:endf[unction],结束用户函数
cn,EX 命令,:en[dif],结束最近的 :if
cn,EX 命令,:endt[ry],结束最近的 :try
cn,EX 命令,:endw[hile],结束最近的 :while
cn,EX 命令,:ene[w],编辑新的无名缓冲区
cn,EX 命令,:ex,"等同于 "":edit"""
cn,EX 命令,:exe[cute],执行表达式的结果产生的字符串
cn,EX 命令,:exi[t],"等同于 "":xit"""
cn,EX 命令,:exu[sage],Ex 命令总览
cn,EX 命令,:f[ile],显示或者设置当前文件名
cn,EX 命令,:files,列出缓冲区列表的所有文件
cn,EX 命令,:filet[ype],切换文件类型检测的打开/关闭
cn,EX 命令,:fina[lly],:try 命令的一部分
cn,EX 命令,:fin[d],在 'path' 里找寻文件并编辑之
cn,EX 命令,:fini[sh],退出 Vim 脚本的执行
cn,EX 命令,:fir[st],转到参数列表的第一个文件
cn,EX 命令,:fix[del],设置 <Del> 的键码
cn,EX 命令,:fo[ld],创建折叠
cn,EX 命令,:foldc[lose],关闭折叠
cn,EX 命令,:folddoc[losed],对所有在关闭折叠的行执行命令
cn,EX 命令,:foldd[oopen],对所有不在关闭折叠的行执行命令
cn,EX 命令,:foldo[pen],打开折叠
cn,EX 命令,:for,for 循环
cn,EX 命令,:fu[nction],定义用户函数
cn,EX 命令,:g[lobal],对匹配的行执行命令
cn,EX 命令,:go[to],转到缓冲区某字节处
cn,EX 命令,:gr[ep],执行 'grepprg' 并转到第一个匹配处
cn,EX 命令,:grepa[dd],类似 :grep，但附加到当前列表后
cn,EX 命令,:gu[i],启动 GUI
cn,EX 命令,:gv[im],启动 GUI
cn,EX 命令,:ha[rdcopy],发送文本到打印机
cn,EX 命令,:h[elp],打开帮助窗口
cn,EX 命令,:helpf[ind],打开显示帮助窗口的对话框
cn,EX 命令,:helpg[rep],"类似于 "":grep""，但搜索帮助文件"
cn,EX 命令,:helpt[ags],为一个目录产生帮助标签
cn,EX 命令,:hid[e],为一个命令隐藏当前缓冲区
cn,EX 命令,:hi[ghlight],指定高亮方法
cn,EX 命令,:his[tory],显示历史列表
cn,EX 命令,:ia[bbrev],"类似于 "":abbrev""，但用于插入模式"
cn,EX 命令,:iabc[lear],"类似于 "":abclear""，但用于插入模式"
cn,EX 命令,:if,条件满足时执行命令
cn,EX 命令,:ij[ump],跳转到标识符的定义
cn,EX 命令,:il[ist],列出匹配标识符的行
cn,EX 命令,:im[ap],"类似于 "":map""，但用于插入模式"
cn,EX 命令,:imapc[lear],"类似于 "":map""，但用于插入模式"
cn,EX 命令,:ime[nu],为插入模式增加菜单
cn,EX 命令,:inorea[bbrev],"类似于 "":noreabbrev""，但用于插入模式"
cn,EX 命令,:ino[remap],"类似于 "":noremap""，但用于插入模式"
cn,EX 命令,:inoreme[nu],"类似于 "":noremenu""，但用于插入模式"
cn,EX 命令,:i[nsert],插入文本
cn,EX 命令,:int[ro],显示介绍文字
cn,EX 命令,:is[earch],列出匹配标识符的一行
cn,EX 命令,:isp[lit],分割窗口，并跳转到标识符的定义
cn,EX 命令,:iuna[bbrev],"类似于 "":unabbrev""，但用于插入模式"
cn,EX 命令,:iu[nmap],"类似于 "":unmap""，但用于插入模式"
cn,EX 命令,:iunme[nu],删除插入模式的菜单
cn,EX 命令,:j[oin],连接行
cn,EX 命令,:ju[mps],显示跳转表
cn,EX 命令,:k,设置位置标记
cn,EX 命令,:keepa[lt],跟随的命令保持轮换文件不变
cn,EX 命令,:keepj[jumps],跟随的命令保持跳转表和位置标记不变
cn,EX 命令,:kee[pmarks],跟随的命令保持位置标记不变
cn,EX 命令,:laddb[uffer],通过缓冲区补充位置
cn,EX 命令,:lad[dexpr],通过表达式补充位置
cn,EX 命令,:laddf[ile],把位置加到当前位置列表里
cn,EX 命令,:lan[guage],设置语言 (locale)
cn,EX 命令,:la[st],转到参数列表的最后一个文件
cn,EX 命令,:lat[er],转到新的改变，重做
cn,EX 命令,:lb[uffer],分析位置并跳转到第一个位置
cn,EX 命令,:lc[d],改变本地的目录
cn,EX 命令,:lch[dir],改变本地的目录
cn,EX 命令,:lcl[ose],关闭位置窗口
cn,EX 命令,:lcs[cope],"类似于 "":cscope""，但使用位置列表"
cn,EX 命令,:le[ft],左对齐行
cn,EX 命令,:lefta[bove],使得分割的窗口出现在左侧或者上方
cn,EX 命令,:let,给变量或选项赋值
cn,EX 命令,:lex[pr],从表达式里读取位置并跳转到第一个
cn,EX 命令,:lf[ile],从文件里读取位置并跳转到第一个
cn,EX 命令,:lfir[st],转到指定的位置上，缺省第一个
cn,EX 命令,:lgetb[uffer],从缓冲区里读取位置
cn,EX 命令,:lgete[xpr],从表达式里读取位置
cn,EX 命令,:lg[etfile],从文件里读取位置
cn,EX 命令,:lgr[ep],运行 'grepprg' 并跳转到第一个匹配
cn,EX 命令,:lgrepa[dd],类似于 :grep，但附加到当前列表上
cn,EX 命令,:lh[elpgrep],"类似于 "":helpgrep""，但使用位置列表"
cn,EX 命令,:l[ist],显示行
cn,EX 命令,:ll,转到指定位置
cn,EX 命令,:lla[st],转到指定位置，缺省最后一个
cn,EX 命令,:lli[st],列出所有的位置
cn,EX 命令,:lmak[e],执行外部命令 'makeprg' 并分析错误信息
cn,EX 命令,:lm[ap],"类似于 "":map!""，但包括 Lang-Arg 模式"
cn,EX 命令,:lmapc[lear],"类似于 "":mapclear!""，但包括 Lang-Arg 模式"
cn,EX 命令,:lnew[er],跳到较新的位置列表
cn,EX 命令,:lne[xt],跳到下一个位置
cn,EX 命令,:lN[ext],转到位置列表的上一个位置
cn,EX 命令,:lnf[ile],跳到下一个文件的第一个位置
cn,EX 命令,:lNf[ile],转到上个文件的最近一个位置
cn,EX 命令,:ln[oremap],"类似于 "":noremap!""，但包括 Lang-Arg 模式"
cn,EX 命令,:loadk[eymap],载入后面的键盘映射表，直到 EOF 为止
cn,EX 命令,:lo[adview],从文件里为当前窗口载入视图
cn,EX 命令,:loc[kmarks],跟随的命令保持位置标记不变
cn,EX 命令,:lockv[ar],给变量加锁
cn,EX 命令,:lol[der],转到较旧的位置列表
cn,EX 命令,:lope[n],打开位置窗口
cn,EX 命令,:lpf[ile],转到上一个文件的最近的位置
cn,EX 命令,:lp[revious],转到前一个位置
cn,EX 命令,:lr[ewind],转到指定的位置，缺省第一个
cn,EX 命令,:ls,列出所有的缓冲区
cn,EX 命令,:lt[ag],跳转到标签，并把匹配的标签加到位置列表上
cn,EX 命令,:lua,执行 |Lua| 命令
cn,EX 命令,:luad[o],对每行都执行 Lua 命令
cn,EX 命令,:luaf[ile],执行 |Lua| 脚本文件
cn,EX 命令,:lu[nmap],"类似于 "":unmap!""，但包括 Lang-Arg 模式"
cn,EX 命令,:lv[imgrep],在若干文件里搜索模式
cn,EX 命令,:lvimgrepa[dd],类似于 :vimgrep，但附加到当前列表
cn,EX 命令,:lw[indow],打开或关闭位置窗口
cn,EX 命令,:mak[e],执行外部命令 'makeprg' 并分析其错误信息
cn,EX 命令,:map,显示或者输入映射
cn,EX 命令,:mapc[lear],清除所有普通和可视模式的映射
cn,EX 命令,:ma[rk],设置位置标记
cn,EX 命令,:marks,列出所有的位置标记
cn,EX 命令,:mat[ch],定义要高亮显示的匹配的模式
cn,EX 命令,:me[nu],输入新的菜单项
cn,EX 命令,:menut[ranslate],增加菜单翻译项目
cn,EX 命令,:mes[sages],显示以前显示的消息
cn,EX 命令,:mk[exrc],写入当前映射和设置到文件
cn,EX 命令,:mks[ession],写入会话信息到文件
cn,EX 命令,:mksp[ell],生成 .spl 拼写文件
cn,EX 命令,:mkvie[w],写入当前窗口的视图到文件
cn,EX 命令,:mkv[imrc],写入当前映射和设置到文件
cn,EX 命令,:mod[e],显示或者改变屏幕模式
cn,EX 命令,:m[ove],移动行
cn,EX 命令,:mzf[ile],执行 MzScheme 脚本文件
cn,EX 命令,:mz[scheme],执行 MzScheme 命令
cn,EX 命令,:nbc[lose],关闭当前 Netbeans 会话
cn,EX 命令,:nb[key],传递一个键给 Netbeans
cn,EX 命令,:nbs[art],打开一个新的 Netbeans 会话
cn,EX 命令,:new,创建一个新的空白窗口
cn,EX 命令,:n[ext],跳转到参数列表的下一个文件
cn,EX 命令,:N[ext],转到参数列表的上一个文件
cn,EX 命令,:nm[ap],"类似于 "":map""，但使用普通模式"
cn,EX 命令,:nmapc[lear],清除普通模式的所有映射
cn,EX 命令,:nme[nu],为普通模式增加菜单
cn,EX 命令,:nn[oremap],"类似于 "":noremap""，但使用普通模式"
cn,EX 命令,:nnoreme[nu],"类似于 "":noremenu""，但使用普通模式"
cn,EX 命令,:noa[utocmd],跟随的命令不激活自动命令
cn,EX 命令,:noh[lsearch],暂停 'hlsearch' 高亮
cn,EX 命令,:norea[bbrev],输入不会被重新映射的缩写
cn,EX 命令,:no[remap],输入不会被重新映射的映射
cn,EX 命令,:noreme[nu],输入不会被重新映射的菜单
cn,EX 命令,:norm[al],执行普通模式的命令
cn,EX 命令,:nu[mber],显示文本行时给出行号
cn,EX 命令,:nun[map],"类似于 "":unmap""，但使用普通模式"
cn,EX 命令,:nunme[nu],删除普通模式的菜单
cn,EX 命令,:ol[dfiles],列出 viminfo 文件中包含位置标记的文件
cn,EX 命令,:om[ap],"类似于 "":map""，但使用操作符等待模式"
cn,EX 命令,:omapc[lear],删除操作符等待模式的所有映射
cn,EX 命令,:ome[nu],为操作符等待模式增加菜单
cn,EX 命令,:on[ly],关闭当前窗口，除了当前的窗口以外
cn,EX 命令,:ono[remap],"类似于 "":noremap""，但使用操作符等待模式"
cn,EX 命令,:onoreme[nu],"类似于 "":noremenu""，但使用操作符等待模式"
cn,EX 命令,:o[pen],启动打开模式 (没有实现)
cn,EX 命令,:opt[ions],打开选项窗口
cn,EX 命令,:ou[nmap],"类似于 "":unmap""，但使用操作符等待模式"
cn,EX 命令,:ounme[nu],删除操作符等待模式的菜单
cn,EX 命令,:ow[nsyntax],为本窗口设置新的局部语法高亮
cn,EX 命令,:pc[lose],关闭预览窗口
cn,EX 命令,:ped[it],在预览窗口编辑文件
cn,EX 命令,:pe[rl],执行 Perl 命令
cn,EX 命令,:perld[o],对每行都执行 Perl 命令
cn,EX 命令,:po[p],跳转到标签栈较旧的项目上
cn,EX 命令,:pop[up],根据名字弹出菜单
cn,EX 命令,:pp[op],"在预览窗口 "":pop"""
cn,EX 命令,:pre[serve],写入所有文本到交换文件
cn,EX 命令,:prev[ious],跳转到参数列表里的上一个文件
cn,EX 命令,:p[rint],显示行
cn,EX 命令,:P[rint],显示行
cn,EX 命令,:profd[el],停止剖视 (profile) 函数或脚本
cn,EX 命令,:prof[ile],剖视 (profile) 函数或脚本
cn,EX 命令,:pro[mptfind],打开 GUI 对话框进行搜索
cn,EX 命令,:promptr[epl],打开 GUI 对话框进行搜索/替代
cn,EX 命令,:ps[earch],"类似于 "":ijump""，但在预览窗口显示匹配"
cn,EX 命令,:pt[ag],在预览窗口显示标签
cn,EX 命令,:ptf[irst],在预览窗口 |:trewind|
cn,EX 命令,:ptj[ump],在预览窗口 |:tjump| 和显示标签
cn,EX 命令,:ptl[ast],在预览窗口 |:tlast|
cn,EX 命令,:ptn[ext],在预览窗口 |:tnext|
cn,EX 命令,:ptN[ext],在预览窗口 |:tNext|
cn,EX 命令,:ptp[revious],在预览窗口 |:tprevious|
cn,EX 命令,:ptr[ewind],在预览窗口 |:trewind|
cn,EX 命令,:pts[elect],在预览窗口 |:tselect| 和显示标签
cn,EX 命令,:pu[t],插入寄存器的内容到文本
cn,EX 命令,:pw[d],显示当前目录
cn,EX 命令,:py3,执行 Python 3 命令
cn,EX 命令,:py3f[ile],执行 Python 3 脚本文件
cn,EX 命令,:pyf[ile],执行 Python 脚本文件
cn,EX 命令,:py[thon],执行 Python 命令
cn,EX 命令,:python3,同 :py3
cn,EX 命令,:qa[ll],退出 Vim
cn,EX 命令,:q[uit],退出当前窗口 (如果只有一窗口，则退出 Vim)
cn,EX 命令,:quita[ll],退出 Vim
cn,EX 命令,:r[ead],读入文件到文本
cn,EX 命令,:rec[over],从交换文件里恢复文件
cn,EX 命令,:redi[r],重定向消息到文件或者寄存器
cn,EX 命令,:red[o],重做一次撤销的改变
cn,EX 命令,:redr[aw],强迫显示的重画
cn,EX 命令,:redraws[tatus],强迫状态行的重画
cn,EX 命令,:reg[isters],显示寄存器的内容
cn,EX 命令,:res[ize],改变当前窗口的高度
cn,EX 命令,:ret[ab],改变制表大小
cn,EX 命令,:retu[rn],从用户函数返回
cn,EX 命令,:rew[ind],转到参数列表的第一个文件
cn,EX 命令,:ri[ght],右对齐文本
cn,EX 命令,:rightb[elow],使得分割窗口出现在右侧或者下方
cn,EX 命令,:rub[y],执行 Ruby 命令
cn,EX 命令,:rubyd[o],对每行执行 Ruby 命令
cn,EX 命令,:rubyf[ile],执行 Ruby 脚本文件
cn,EX 命令,:rund[o],从文件里读入撤销信息
cn,EX 命令,:ru[ntime],执行 'runtimepath' 里的 vim 脚本
cn,EX 命令,:rv[iminfo],读取 viminfo 文件
cn,EX 命令,:sal[l],为参数列表的每个文件打开窗口
cn,EX 命令,:san[dbox],在沙盘里执行命令
cn,EX 命令,:sa[rgument],分割窗口并转到参数列表的某一个文件
cn,EX 命令,:sav[eas],用别的名字保存文件。
cn,EX 命令,:sba[ll],为缓冲区列表的每个文件打开窗口
cn,EX 命令,:sbf[irst],分割窗口并转到缓冲区列表的第一个文件
cn,EX 命令,:sbl[ast],分割窗口并转到缓冲区列表的最后一个文件
cn,EX 命令,:sbm[odified],分割窗口并转到缓冲区列表的修改过的文件
cn,EX 命令,:sbn[ext],分割窗口并转到缓冲区列表的后一个文件
cn,EX 命令,:sbN[ext],分割窗口并转到缓冲区列表的前一个文件
cn,EX 命令,:sbp[revious],分割窗口并转到缓冲区列表的前一个文件
cn,EX 命令,:sbr[ewind],分割窗口并转到缓冲区列表的第一个文件
cn,EX 命令,:sb[uffer],分割窗口并转到缓冲区列表的某一个文件
cn,EX 命令,:scripte[ncoding],执行过的 Vim 脚本使用的编码
cn,EX 命令,:scrip[tnames],列出所有执行过的 Vim 脚本的名字
cn,EX 命令,:scs[cope],分割窗口并执行 cscope 命令
cn,EX 命令,:se[t],显示或设置选项
cn,EX 命令,:setf[iletype],设置 'filetype'，除非已经设置过
cn,EX 命令,:setg[lobal],显示或者设置全局选项值
cn,EX 命令,:setl[ocal],显示或者设置本地选项值
cn,EX 命令,:sf[ind],分割当前窗口并编辑 'path' 的文件
cn,EX 命令,:sfir[st],分割窗口并转到参数列表的第一个文件
cn,EX 命令,:sh[ell],退到外壳程序
cn,EX 命令,:sig[n],操作标号
cn,EX 命令,:sil[ent],安静地运行命令
cn,EX 命令,:sim[alt],Win32 GUI: 模拟 Windows ALT 键
cn,EX 命令,:sla[st],分割窗口并转到参数列表的最后一个文件
cn,EX 命令,:sl[eep],几秒内不作任何事
cn,EX 命令,:sm[agic],带 'magic' 的 :substitute
cn,EX 命令,:sma[p],"类似于 "":map""，但用于选择模式"
cn,EX 命令,:smapc[lear],删除选择模式所有的映射
cn,EX 命令,:sme[nu],增加选择模式菜单
cn,EX 命令,:sn[ext],分割窗口并转到参数列表的下一个文件
cn,EX 命令,:sN[ext],分割窗口并转到参数列表的前一个文件
cn,EX 命令,:sni[ff],发送请求到 sniff
cn,EX 命令,:sno[magic],带 'nomagic' 的 :substitute
cn,EX 命令,:snor[emap],"类似于 "":noremap""，但用于选择模式"
cn,EX 命令,:snoreme[nu],"类似于 "":noremenu""，但用于选择模式"
cn,EX 命令,:sor[t],给行排序
cn,EX 命令,:so[urce],从文件里读取 Vim 或 Ex 命令
cn,EX 命令,:spelld[ump],分割窗口并用正确的单词填充
cn,EX 命令,:spe[llgood],增加拼写的好词
cn,EX 命令,:spelli[nfo],显示载入的拼写文件的信息
cn,EX 命令,:spellr[epall],像上次 |z=| 那样，但替换所有的坏词
cn,EX 命令,:spellu[ndo],删除好词或坏词
cn,EX 命令,:spellw[rong],增加拼写错误
cn,EX 命令,:sp[lit],分割当前窗口
cn,EX 命令,:spr[evious],分割窗口并转到参数列表的前一个文件
cn,EX 命令,:sre[wind],分割窗口并转到参数列表的第一个文件
cn,EX 命令,:sta[g],分割窗口并跳转到标签上
cn,EX 命令,:startg[replace],开始虚拟替换模式
cn,EX 命令,:star[tinsert],开始插入模式
cn,EX 命令,:startr[eplace],开始替换模式
cn,EX 命令,:stj[ump],"执行 "":tjump"" 并分割窗口"
cn,EX 命令,:st[op],暂停编辑器并退回外壳
cn,EX 命令,:stopi[nsert],退出插入模式
cn,EX 命令,:sts[elect],"执行 "":tselect"" 并分割窗口"
cn,EX 命令,:s[ubstitute],查找和替代文本
cn,EX 命令,:sun[hide],"等同于 "":unhide"""
cn,EX 命令,:sunm[ap],"类似于 "":unmap""，但用于选择模式"
cn,EX 命令,:sunme[nu],删除选择模式的菜单
cn,EX 命令,:sus[pend],"等同于 "":stop"""
cn,EX 命令,:sv[iew],分割窗口并以只读模式编辑文件
cn,EX 命令,:sw[apname],显示当前交换文件的名字
cn,EX 命令,:sync[bind],同步滚动绑定
cn,EX 命令,:sy[ntax],语法高亮
cn,EX 命令,:t,"等同于 "":copy"""
cn,EX 命令,:tab,打开新窗口时建立新的标签页
cn,EX 命令,:tabc[lose],关闭当前标签页
cn,EX 命令,:tabdo,为每个标签页执行命令
cn,EX 命令,:tabe[dit],在新标签页里编辑文件
cn,EX 命令,:tabf[ind],寻找 'path' 里的文件，在新标签页里编辑之
cn,EX 命令,:tabfir[st],转到第一个标签页
cn,EX 命令,:tabl[ast],转到最后一个标签页
cn,EX 命令,:tabm[ove],把标签页移到别的位置
cn,EX 命令,:tabnew,在新标签页里编辑文件
cn,EX 命令,:tabn[ext],转到下一个标签页
cn,EX 命令,:tabN[ext],跳到上一个标签页
cn,EX 命令,:tabo[nly],关闭所有除了当前标签页以外的所有标签页
cn,EX 命令,:tabp[revious],转到前一个标签页
cn,EX 命令,:tabr[ewind],转到第一个标签页
cn,EX 命令,:tabs,列出标签页以及里面包含的内容
cn,EX 命令,:ta[g],跳转到标签上
cn,EX 命令,:tags,显示标签栈的内容
cn,EX 命令,:tc[l],执行 Tcl 命令
cn,EX 命令,:tcld[o],为每行执行 Tcl 命令
cn,EX 命令,:tclf[ile],执行 Tcl 脚本文件
cn,EX 命令,:te[aroff],撕下一个菜单
cn,EX 命令,:tf[irst],转到第一个匹配的标签
cn,EX 命令,:th[row],抛出例外
cn,EX 命令,:tj[ump],"类似于 "":tselect""，只有一个匹配时直接跳转之"
cn,EX 命令,:tl[ast],跳转到最后一个匹配的标签
cn,EX 命令,:tm[enu],定义菜单的工具提示
cn,EX 命令,:tn[ext],跳转到下一个匹配的标签
cn,EX 命令,:tN[ext],跳转到上一个匹配的标签
cn,EX 命令,:to[pleft],使得分割的窗口出现在顶部或者最左端
cn,EX 命令,:tp[revious],跳转到上一个匹配的标签
cn,EX 命令,:tr[ewind],跳转到第一个匹配的标签
cn,EX 命令,:try,执行命令，错误或者例外时终止
cn,EX 命令,:ts[elect],列出匹配的标签并从中选择一个
cn,EX 命令,:tu[nmenu],删除菜单的工具提示
cn,EX 命令,:una[bbreviate],删除缩写
cn,EX 命令,:u[ndo],撤销最近的改变
cn,EX 命令,:undoj[oin],将下一个改变和上一个撤销块合并
cn,EX 命令,:undol[ist],列出撤销树的叶结点
cn,EX 命令,:unh[ide],为缓冲区列表里每个载入的文件打开窗口
cn,EX 命令,:unl[et],删除变量
cn,EX 命令,:unlo[ckvar],给变量解锁
cn,EX 命令,:unm[ap],删除映射
cn,EX 命令,:unme[nu],删除菜单
cn,EX 命令,:uns[ilent],非安静模式执行命令
cn,EX 命令,:up[date],如果有修改，写回缓冲区
cn,EX 命令,:verb[ose],执行命令，过程中设置 'verbose'
cn,EX 命令,:ve[rsion],显示版本号和其它信息
cn,EX 命令,:vert[ical],使得跟随的命令垂直分割
cn,EX 命令,:v[global],对不匹配的行，执行命令
cn,EX 命令,:vie[w],以只读方式编辑文件
cn,EX 命令,:vim[grep],在若干文件里查找模式
cn,EX 命令,:vimgrepa[dd],类似于 :vimgrep，但附加到当前列表
cn,EX 命令,:vi[sual],"等同于 "":edit""，但关掉 ""Ex"" 模式"
cn,EX 命令,:viu[sage],普通模式命令的总览
cn,EX 命令,:vm[ap],"类似于 "":map""，但使用可视+选择模式"
cn,EX 命令,:vmapc[lear],删除可视+选择模式所有的映射
cn,EX 命令,:vme[nu],为可视+选择模式增加菜单
cn,EX 命令,:vne[w],建立新的空白窗口，垂直分割
cn,EX 命令,:vn[oremap],"类似于 "":noremap""，但使用可视+选择模式"
cn,EX 命令,:vnoreme[nu],"类似于 "":noremenu""，但使用可视+选择模式"
cn,EX 命令,:vs[plit],垂直分割当前窗口
cn,EX 命令,:vu[nmap],"类似于 "":unmap""，但使用可视+选择模式"
cn,EX 命令,:vunme[nu],删除可视+选择模式的菜单
cn,EX 命令,:wa[ll],写回所有 (改变的) 缓冲区
cn,EX 命令,:wh[ile],只要条件满足，执行循环体
cn,EX 命令,:winc[md],执行窗口 (CTRL-W) 命令
cn,EX 命令,:windo,为每个窗口执行命令
cn,EX 命令,:winp[os],取得或者设置窗口位置
cn,EX 命令,:wi[nsize],取得或者设置窗口大小 (已废弃)
cn,EX 命令,:wn[ext],写回文件，然后跳转到参数列表的下一个文件
cn,EX 命令,:wN[ext],写回文件，然后跳转到参数列表的前一个文件
cn,EX 命令,:wp[revious],写回文件，然后跳转到参数列表的前一个文件
cn,EX 命令,:wq,写回文件，然后退出窗口或者 Vim
cn,EX 命令,:wqa[ll],写回所有 (改变的) 缓冲区然后退出 Vim
cn,EX 命令,:w[rite],写回文件
cn,EX 命令,:ws[verb],把动词通过 IPC 发送给 workshop
cn,EX 命令,:wu[ndo],把撤销信息写入文件
cn,EX 命令,:wv[iminfo],写入 viminfo 文件
cn,EX 命令,:X,请求加密密钥
cn,EX 命令,:xa[ll],"等同于 "":wqall"""
cn,EX 命令,:x[it],如果缓冲区被改动，写入之。然后退出窗口或者 Vim
cn,EX 命令,:xm[ap],"类似于 "":map""，但使用可视模式"
cn,EX 命令,:xmapc[lear],删除可视模式的所有映射
cn,EX 命令,:xme[nu],增加可视模式的菜单
cn,EX 命令,:xn[oremap],"类似于 "":noremap""，但使用可视模式"
cn,EX 命令,:xnoreme[nu],"类似于 "":noremenu""，但使用可视模式"
cn,EX 命令,:xu[nmap],"类似于 "":unmap""，但使用可视模式"
cn,EX 命令,:xunme[nu],删除可视模式的菜单
cn,EX 命令,:y[ank],抽出行到寄存器
cn,EX 命令,:z,显示一些行
cn,'g' 开始的命令,g#,"类似于 ""#""，但不使用 ""<"" 和 "">"""
cn,'g' 开始的命令,g&,"在所有行上重复上次的 "":s"""
cn,'g' 开始的命令,g*,"类似于 ""*""，但不使用 ""<"" 和 "">"""
cn,'g' 开始的命令,g<,显示上次的命令输出
cn,'g' 开始的命令,g?,Rot13 编码操作符
cn,'g' 开始的命令,g??,Rot13 编码当前行
cn,'g' 开始的命令,g],:tselect 到光标所在的标签上
cn,'g' 开始的命令,g^,'wrap' 关闭时转到当前行最左侧屏幕上可见的非空白字符'wrap' 打开时转到当前屏幕行最左侧的非空白字符
cn,'g' 开始的命令,g$,'wrap' 关闭时转到当前行最右侧屏幕上可见的字符'wrap' 打开时转到当前屏幕行最右侧的字符
cn,'g' 开始的命令,g0,'wrap' 关闭时转到当前行最左侧屏幕上可见的字符'wrap' 打开时转到当前屏幕行最左侧的字符
cn,'g' 开始的命令,g8,显示光标所在的 UTF-8 字符的十六进制字节码
cn,'g' 开始的命令,ga,打印光标所在处的字符的 ascii 值
cn,'g' 开始的命令,g CTRL-],|:tjump| 到光标所在的标签上
cn,'g' 开始的命令,g CTRL-A,只有在编译时加入了 MEM_PROFILE 时才有定义:转储内存内容
cn,'g' 开始的命令,g CTRL-G,显示当前光标位置
cn,'g' 开始的命令,g CTRL-H,启动选择列块模式
cn,'g' 开始的命令,gd,转到当前函数里当前光标所在的单词的定义
cn,'g' 开始的命令,gD,转到当前文件的光标所在单词的定义
cn,'g' 开始的命令,g<Down>,"等同于 ""gj"""
cn,'g' 开始的命令,ge,反向转到前一个单词的结尾处
cn,'g' 开始的命令,gE,反向转移到上一个 WORD 的结尾处
cn,'g' 开始的命令,g<End>,"等同于 ""g$"""
cn,'g' 开始的命令,gf,开始编辑当前光标所在的名字对应的文件
cn,'g' 开始的命令,gF,开始编辑光标所在的文件名并跳转到文件名后的行号上。
cn,'g' 开始的命令,g?g?,Rot13 编码当前行
cn,'g' 开始的命令,gg,光标移动到第 N 行，缺省是第一行
cn,'g' 开始的命令,gh,开始选择模式
cn,'g' 开始的命令,gH,启动选择行模式
cn,'g' 开始的命令,g<Home>,"等同于 ""g0"""
cn,'g' 开始的命令,gi,"类似于 ""i""，但先移动到 |'^| 位置标记"
cn,'g' 开始的命令,gI,"类似于 ""I""，但总是从第一列开始"
cn,'g' 开始的命令,gj,"类似于 ""j""，但 'wrap' 打开时往下 N 个屏幕行"
cn,'g' 开始的命令,gJ,连接行，不插入空格
cn,'g' 开始的命令,gk,"类似于 ""k""，但 'wrap' 打开时往上 N 个屏幕行"
cn,'g' 开始的命令,g<LeftMouse>,等同于 <C-LeftMouse>
cn,'g' 开始的命令,gm,转到屏幕行正中间的那个字符
cn,'g' 开始的命令,g'{mark},类似于 |'|，但不改变跳转表
cn,'g' 开始的命令,g`{mark},类似于 |`|，但不改表跳转表
cn,'g' 开始的命令,g<MiddleMouse>,等同于 <C-MiddleMouse>
cn,'g' 开始的命令,g@{motion},调用 'operatorfunc'
cn,'g' 开始的命令,g~{motion},改变 Nmove 文本的大小写
cn,'g' 开始的命令,go,光标移动到缓冲区的第 N 个字节
cn,'g' 开始的命令,gq{motion},排版 Nmove 文本
cn,'g' 开始的命令,gR,进入虚拟替换模式
cn,'g' 开始的命令,gr{char},虚拟替换 N 个字符为 {char}
cn,'g' 开始的命令,g<RightMouse>,等同于 <C-RightMouse>
cn,'g' 开始的命令,gs,睡眠 N 秒 (缺省 1)
cn,'g' 开始的命令,gu{motion},使得 Nmove 文本全部小写
cn,'g' 开始的命令,gU{motion},使得 Nmove 文本全部大写
cn,'g' 开始的命令,g<Up>,"等同于 ""gk"""
cn,'g' 开始的命令,gv,重新选择上次的可视区域
cn,'g' 开始的命令,gV,在执行选择模式下的映射或者菜单时，不要重复选择过去的可视区域
cn,'g' 开始的命令,gw{motion},排版 Nmove 文本并保持光标位置
cn,'g' 开始的命令,gx,执行光标下的文件名对应的应用程序 (仅限于|netrw| 插件)
cn,'g' 开始的命令,"[""x]gp",在光标后面放置文本 [从寄存器 x] N 次，光标留在后面
cn,'g' 开始的命令,"[""x]gP",在光标签放置文本 [从寄存器 x] N 次，光标留在插入文本之后
cn,'z' 开始的命令,z+,"光标移动到第 N 行 (缺省为窗口之后的第一行)，其它同 ""z<CR>"""
cn,'z' 开始的命令,z-,重画，光标移动到窗口末行的第一个非空白字符
cn,'z' 开始的命令,z.,重画，光标移动到窗口的中间行的第一个非空白字符
cn,'z' 开始的命令,z=,给出拼写建议
cn,'z' 开始的命令,z^,"光标移动到第 N 行 (缺省为窗口之前的一行)，其它同 ""z-"""
cn,'z' 开始的命令,za,打开关闭的折叠，或关闭打开的折叠
cn,'z' 开始的命令,zA,递归打开一个关闭的折叠或关闭一个打开的折叠
cn,'z' 开始的命令,zb,重画，光标在窗口底行
cn,'z' 开始的命令,zc,关闭折叠
cn,'z' 开始的命令,zC,递归关闭折叠
cn,'z' 开始的命令,z<CR>,重画，光标移动到窗口的顶行的第一个非空白字符
cn,'z' 开始的命令,zd,删除折叠
cn,'z' 开始的命令,zD,递归删除折叠
cn,'z' 开始的命令,ze,'wrap' 关闭时，水平滚动使得光标定位到屏幕的尾部 (最右侧)
cn,'z' 开始的命令,zE,除去所有折叠
cn,'z' 开始的命令,zF,为 N 行建立折叠
cn,'z' 开始的命令,zf{motion},为 Nmove 文本建立折叠
cn,'z' 开始的命令,zg,把单词标记为拼写正确 (good)
cn,'z' 开始的命令,zG,把单词标记为拼写正确 (good)
cn,'z' 开始的命令,zh,'wrap' 关闭时，水平右滚屏幕 N 个字符
cn,'z' 开始的命令,z{height}<CR>,重画，使得窗口高度为 {height} 行
cn,'z' 开始的命令,zi,切换 'foldenable'
cn,'z' 开始的命令,zj,移动到下一个折叠的开始处
cn,'z' 开始的命令,zk,移动到前一个折叠的结束处
cn,'z' 开始的命令,zl,'wrap' 关闭时，水平左滚屏幕 N 个字符
cn,'z' 开始的命令,z<Left>,"等同于 ""zh"""
cn,'z' 开始的命令,zm,从 'foldlevel' 减一
cn,'z' 开始的命令,zM,设置 'foldlevel' 为零
cn,'z' 开始的命令,zn,复位 'foldenable'
cn,'z' 开始的命令,zN,置位 'foldenable'
cn,'z' 开始的命令,zo,打开折叠
cn,'z' 开始的命令,zO,递归打开折叠
cn,'z' 开始的命令,zr,给 'foldlevel' 加一
cn,'z' 开始的命令,zR,设置 'foldlevel' 为最大折叠级别
cn,'z' 开始的命令,z<Right>,"等同于 ""zl"""
cn,'z' 开始的命令,zs,'wrap' 关闭时，水平滚动使得光标定位到屏幕的起始处 (最左侧)
cn,'z' 开始的命令,zt,重画，光标移动到窗口的顶部
cn,'z' 开始的命令,zv,打开足够的折叠，使得当前行可见
cn,'z' 开始的命令,zw,把单词标记为拼写错误 (wrong)
cn,'z' 开始的命令,zW,把单词标记为拼写错误 (wrong)
cn,'z' 开始的命令,zx,"重新应用 'foldlevel' 然后执行 ""zv"""
cn,'z' 开始的命令,zX,重新应用 'foldlevel'
cn,'z' 开始的命令,zz,重画，光标移动到窗口的中间行
cn,可视模式,:,使用高亮行作为范围，开始一个命令行
cn,可视模式,<,左移高亮行一个 'shiftwidth'
cn,可视模式,=,用 {equalprg} 选项指定的外部程序过滤高亮行
cn,可视模式,>,右移高亮行一个 'shiftwidth'
cn,可视模式,~,改变高亮区域的大小写
cn,可视模式,"a""",扩展高亮区域，使包含一个双引号字符串
cn,可视模式,a',扩展高亮区域，使包含一个单引号字符串
cn,可视模式,a(,等同于 ab
cn,可视模式,a),等同于 ab
cn,可视模式,a<,扩展高亮区域，使包含一个 <> 块
cn,可视模式,a>,等同于 a<
cn,可视模式,a[,扩展高亮区域，使包含一个 [] 块
cn,可视模式,a],等同于 a[
cn,可视模式,a`,扩展高亮区域，使包含一个反引号字符串
cn,可视模式,a{,等同于 aB
cn,可视模式,a},等同于 aB
cn,可视模式,A,列块模式下: 在高亮区域的所有行后附加相同的文本
cn,可视模式,ab,扩展高亮区域，使包含一个 () 块
cn,可视模式,aB,扩展高亮区域，使包含一个 {} 块
cn,可视模式,ap,扩展高亮区域，使包含一个段落
cn,可视模式,as,扩展高亮区域，使包含一个句子
cn,可视模式,at,扩展高亮区域，使包含一个标签块
cn,可视模式,aw,"扩展高亮区域，使包含 ""一个单词"""
cn,可视模式,aW,"扩展高亮区域，使包含 ""一个 WORD"""
cn,可视模式,<BS>,选择模式: 删除高亮区域
cn,可视模式,c,删除高亮区域，并开始插入
cn,可视模式,C,删除高亮行，并开始插入
cn,可视模式,CTRL-],跳转到高亮的标签上
cn,可视模式,CTRL-C,结束可视模式
cn,可视模式,CTRL- CTRL-G,转到 'insertmode' 指定的模式
cn,可视模式,CTRL- CTRL-N,结束可视模式
cn,可视模式,CTRL-G,在可视模式和选择模式间切换
cn,可视模式,CTRL-H,等同于 <BS>
cn,可视模式,CTRL-O,从选择模式切换到可视模式，只限于下个命令
cn,可视模式,CTRL-V,使得可视模式面向列块，或者退出可视模式
cn,可视模式,d,删除高亮区域
cn,可视模式,D,删除高亮行
cn,可视模式,<Esc>,结束可视模式
cn,可视模式,!{filter},通过外部命令 {filter} 过滤高亮行
cn,可视模式,gJ,连接高亮行，不插入空格
cn,可视模式,gq,排版高亮行
cn,可视模式,gv,交换现在和以前的高亮区域
cn,可视模式,"i""",扩展高亮区域，使包含一个双引号字符串 (但不含引号)
cn,可视模式,i',扩展高亮区域，使包含一个单引号字符串 (但不含引号)
cn,可视模式,i(,等同于 ib
cn,可视模式,i),等同于 ib
cn,可视模式,i<,扩展高亮区域，使包含内含 <> 块
cn,可视模式,i>,等同于 i<
cn,可视模式,i[,扩展高亮区域，使包含内含 [] 块
cn,可视模式,i],等同于 i[
cn,可视模式,i`,扩展高亮区域，使包含一个反引号字符串 (但不含反引号)
cn,可视模式,i{,等同于 iB
cn,可视模式,i},等同于 iB
cn,可视模式,I,列块模式: 在所有高亮行之前插入相同的文本
cn,可视模式,ib,扩展高亮区域，使包含内含 () 块
cn,可视模式,iB,扩展高亮区域，使包含内含 {} 块
cn,可视模式,ip,扩展高亮区域，使包含内含段落
cn,可视模式,is,扩展高亮区域，使包含内含句子
cn,可视模式,it,扩展高亮区域，使包含内含标签块
cn,可视模式,iw,"扩展高亮区域，使包含 ""内含单词"""
cn,可视模式,iW,"扩展高亮区域，使包含 ""内含 WORD"""
cn,可视模式,J,连接高亮行
cn,可视模式,K,在高亮区域上运行 'keywordprg'
cn,可视模式,o,移动光标到区域的另一侧
cn,可视模式,O,水平移动到区域的另外一侧
cn,可视模式,Q,不启动 Ex 模式
cn,可视模式,r,删除高亮区域，并开始插入
cn,可视模式,R,删除高亮行并开始插入
cn,可视模式,s,删除高亮区域，并开始插入
cn,可视模式,S,删除高亮行并开始插入
cn,可视模式,u,使得高亮区域全变小写
cn,可视模式,U,使得高亮区域全变大写
cn,可视模式,v,使得可视模式面向字符，或者退出可视模式
cn,可视模式,V,使得可视区域面向行，或者退出可视模式
cn,可视模式,x,删除高亮区域
cn,可视模式,X,删除高亮区域
cn,可视模式,y,抽出高亮区域
cn,可视模式,Y,抽出高亮行
cn,命令行编辑,<BS>,删除光标前面的字符
cn,命令行编辑,{char1} <BS> {char2},'digraph' 打开时，输入二合字母
cn,命令行编辑,<C-Left>,光标左移一个单词
cn,命令行编辑,<CR>,执行输入的命令
cn,命令行编辑,<C-Right>,光标右移一个单词
cn,命令行编辑,CTRL-,其它     不用
cn,命令行编辑,CTRL-[,等同于 <Esc>
cn,命令行编辑,CTRL-],激活缩写
cn,命令行编辑,CTRL-^,切换 |:lmap| 映射的使用
cn,命令行编辑,CTRL-_,'allowrevins'  打开时: 改变语言 (希伯来，波斯)
cn,命令行编辑,CTRL-A,使用光标前面的模式进行补全，并插入所有的匹配
cn,命令行编辑,CTRL- a - d,保留给扩展用
cn,命令行编辑,CTRL-B,光标移动到命令行开始的地方
cn,命令行编辑,CTRL-C,等同于 <ESC>
cn,命令行编辑,CTRL- CTRL-G,转到 'insertmode' 指定的模式，放弃命令行
cn,命令行编辑,CTRL- CTRL-N,转到普通模式，放弃命令行
cn,命令行编辑,CTRL-D,列出光标前面模式的所有补全
cn,命令行编辑,CTRL-E,光标移动到命令行结束的地方
cn,命令行编辑,CTRL- e {expr},以 {expr} 的结果替换命令行
cn,命令行编辑,CTRL-F,'cedit' 的缺省值: 打开命令行窗口；否则不用
cn,命令行编辑,CTRL- f - z,保留给扩展用
cn,命令行编辑,CTRL-H,等同于 <BS>
cn,命令行编辑,CTRL-I,等同于 <Tab>
cn,命令行编辑,CTRL-J,等同于 <CR>
cn,命令行编辑,CTRL-K {char1} {char2},输入二合字母
cn,命令行编辑,CTRL-L,补全光标前的模式，并插入最长的公共子串
cn,命令行编辑,CTRL-M,等同于 <CR>
cn,命令行编辑,CTRL-N,使用 'wildchar' 并有多个匹配: 转到下一个匹配，不然: 等同于 <Down>
cn,命令行编辑,CTRL-O,不同
cn,命令行编辑,CTRL-P,使用 'wildchar' 并有多个匹配: 转到上一个匹配，不然: 等同于 <Up>
cn,命令行编辑,CTRL-Q,等同于 CTRL-V，除非用于终端控制流
cn,命令行编辑,"CTRL-R {0-9a-z""%#*:= CTRL-F CTRL-P CTRL-W CTRL-A}",插入寄存器的内容或特殊对象到光标所在的地方，如同直接输入那样
cn,命令行编辑,"CTRL-R CTRL-R {0-9a-z""%#*:= CTRL-F CTRL-P CTRL-W CTRL-A}",按本义插入寄存器的内容或特殊对象到光标所在的地方
cn,命令行编辑,CTRL-S,(用于终端控制流)
cn,命令行编辑,CTRL-U,删除所有字符
cn,命令行编辑,CTRL-V,按本义插入下一个非数字字符，或者插入其后三位数字所代表的单个字节。
cn,命令行编辑,CTRL-W,删除光标前面的单词
cn,命令行编辑,CTRL-Y,复制 (抽出) 无模式的选择
cn,命令行编辑,<Del>,删除光标所在的字符
cn,命令行编辑,<Down>,从历史中调入匹配光标前模式的后一个命令行
cn,命令行编辑,<End>,光标移动到命令行结束的地方
cn,命令行编辑,<Esc>,放弃命令行，不执行
cn,命令行编辑,<Home>,光标移动到命令行开始的地方
cn,命令行编辑,<Insert>,切换插入/替换模式
cn,命令行编辑,<Left>,光标左移
cn,命令行编辑,<LeftMouse>,光标移动到鼠标点击的地方
cn,命令行编辑,<NL>,等同于 <CR>
cn,命令行编辑,<PageDown>,等同于 <S-Down>
cn,命令行编辑,<PageUp>,等同于 <S-Up>
cn,命令行编辑,<Right>,光标右移
cn,命令行编辑,<S-Down>,从历史中调入后一个命令行
cn,命令行编辑,<S-Left>,光标左移一个单词
cn,命令行编辑,<S-Right>,光标右移一个单词
cn,命令行编辑,<S-Tab>,等同于 CTRL-P
cn,命令行编辑,<S-Up>,从历史中调入前一个命令行
cn,命令行编辑,<Tab>,如果 'wildchar' 是 <Tab>: 补全光标前面的模式
cn,命令行编辑,<Up>,从历史中调入匹配光标前模式的前一个命令行
cn,命令行编辑,'wildchar',补全光标前面的模式 (缺省: <Tab>)
cn,子模式的命令,CTRL-X CTRL-],补全标签
cn,子模式的命令,CTRL-X CTRL-D,补全定义过的标识符
cn,子模式的命令,CTRL-X CTRL-E,上滚
cn,子模式的命令,CTRL-X CTRL-F,补全文件名
cn,子模式的命令,CTRL-X CTRL-I,补全标识符
cn,子模式的命令,CTRL-X CTRL-K,从字典补全标识符
cn,子模式的命令,CTRL-X CTRL-L,补全完整的行
cn,子模式的命令,CTRL-X CTRL-N,下一个补全
cn,子模式的命令,CTRL-X CTRL-O,全能 (omni) 补全
cn,子模式的命令,CTRL-X CTRL-P,上一个补全
cn,子模式的命令,CTRL-X CTRL-S,拼写建议
cn,子模式的命令,CTRL-X CTRL-T,从同义词词典补全标识符
cn,子模式的命令,CTRL-X CTRL-U,用 'completefunc' 补全
cn,子模式的命令,CTRL-X CTRL-V,如同 : 命令行那样补全
cn,子模式的命令,CTRL-X CTRL-Y,下滚
cn,子模式的命令,CTRL-X s,拼写建议
cn,插入模式,0 CTRL-D,删除当前行的所有缩进
cn,插入模式,<BS>,删除光标前的字符
cn,插入模式,<C-End>,光标移到文件尾后面
cn,插入模式,{char1}<BS>{char2},输入二合字母 (只有打开了 'digraph' 选项才有效)
cn,插入模式,<C-Home>,光标移到文件首
cn,插入模式,<C-Left>,光标左移一个单词
cn,插入模式,<CR>,开始新行
cn,插入模式,<C-Right>,光标右移一个单词
cn,插入模式,CTRL-@,插入最近插入的文本并停止插入
cn,插入模式,CTRL-[,等同于 <Esc>
cn,插入模式,CTRL-],切换缩写
cn,插入模式,CTRL-^,切换 |:lmap| 映射的使用
cn,插入模式,CTRL-_,'allowrevins' 打开时: 改变语言(希伯来语，波斯语等) {仅当编译时加入|+rightleft| 特性才有效}
cn,插入模式,CTRL-A,插入最近插入的文本
cn,插入模式,CTRL- a - z,保留给扩展用
cn,插入模式,CTRL-C,退出插入模式，不检查缩写，除非置位了'insertmode'。
cn,插入模式,CTRL- CTRL-G,进入 'insertmode' 指定的模式
cn,插入模式,CTRL- CTRL-N,进入普通模式
cn,插入模式,^ CTRL-D,删除当前行的所有缩进，在下一行恢复删除的缩进
cn,插入模式,CTRL-D,在当前行删除一个 shiftwidth 的缩进
cn,插入模式,CTRL-E,插入光标下方的字符
cn,插入模式,CTRL-G CTRL-J,往下一行，到插入开始的列
cn,插入模式,CTRL-G CTRL-K,往上一行，到插入开始的列
cn,插入模式,CTRL-G <Down>,往下一行，到插入开始的列
cn,插入模式,CTRL-G j,往下一行，到插入开始的列
cn,插入模式,CTRL-G k,往上一行，到插入开始的列
cn,插入模式,CTRL-G u,开始新的不可撤消的编辑
cn,插入模式,CTRL-G <Up>,往上一行，到插入开始的列
cn,插入模式,CTRL-H,等同于 <BS>
cn,插入模式,CTRL-I,等同于 <Tab>
cn,插入模式,CTRL-J,等同于 <CR>
cn,插入模式,CTRL-K {char1} {char2},输入二合字母
cn,插入模式,CTRL-L,'insertmode' 打开时: 离开插入模式
cn,插入模式,CTRL-M,等同于 <CR>
cn,插入模式,CTRL-N,查找光标前面的关键字的下一个匹配
cn,插入模式,CTRL-O,执行单个命令然后回到插入模式
cn,插入模式,CTRL-P,查找光标前面的关键字的前一个匹配
cn,插入模式,CTRL-Q,等同于 CTRL-V，除非它用于终端控制流
cn,插入模式,"CTRL-R {0-9a-z""%#*:=}",插入寄存器内容
cn,插入模式,"CTRL-R CTRL-O {0-9a-z""%#*:=}",按本义插入寄存器内容，而且不自动缩进
cn,插入模式,"CTRL-R CTRL-P {0-9a-z""%#*:=}",按本义插入寄存器内容，而且修正缩进
cn,插入模式,"CTRL-R CTRL-R {0-9a-z""%#*:=}",按本义插入寄存器内容
cn,插入模式,CTRL-S,(用于终端控制流)
cn,插入模式,CTRL-T,在当前行插入一个 shiftwidth 的缩进
cn,插入模式,CTRL-U,删除当前行的所有输入字符
cn,插入模式,CTRL-V {char},按本义插入下一个非数字字符
cn,插入模式,CTRL-V {number},插入三位十进制数字代表的单个字节。
cn,插入模式,CTRL-W,删除光标前的单词
cn,插入模式,CTRL-X {mode},进入 CTRL-X 子模式，见 |i_CTRL-X_index|
cn,插入模式,CTRL-Y,插入光标上方的字符
cn,插入模式,CTRL-Z,'insertmode' 打开时: 暂停 Vim
cn,插入模式,<Del>,删除光标所在的字符
cn,插入模式,<Down>,光标下移一行
cn,插入模式,<End>,光标移到行尾后面
cn,插入模式,<Esc>,结束插入模式 (除非打开了 'insertmode')
cn,插入模式,<F1>,等同于 <Help>
cn,插入模式,<Help>,停止插入模式显示帮助窗口
cn,插入模式,<Home>,光标移到行首
cn,插入模式,<Insert>,切换插入/替换模式
cn,插入模式,<Left>,光标左移一个字符
cn,插入模式,<LeftMouse>,光标移到鼠标点击处
cn,插入模式,<NL>,等同于 <CR>
cn,插入模式,<PageDown>,满屏下滚
cn,插入模式,<PageUp>,满屏上滚
cn,插入模式,<Right>,光标右移一个字符
cn,插入模式,<ScrollWheelDown>,窗口向下滚动三行
cn,插入模式,<ScrollWheelLeft>,窗口向左滚动六列
cn,插入模式,<ScrollWheelRight>,窗口向右滚动六列
cn,插入模式,<ScrollWheelUp>,窗口向上滚动三行
cn,插入模式,<S-Down>,等同于 <PageDown>
cn,插入模式,<S-Left>,光标左移一个单词
cn,插入模式,<S-Right>,光标右移一个单词
cn,插入模式,<S-ScrollWheelDown>,窗口向下滚动完整一页
cn,插入模式,<S-ScrollWheelLeft>,窗口向左滚动完整一页
cn,插入模式,<S-ScrollWheelRight>,窗口向右滚动完整一页
cn,插入模式,<S-ScrollWheelUp>,窗口向上滚动完整一页
cn,插入模式,<S-Up>,等同于 <PageUp>
cn,插入模式,<Tab>,插入 <Tab> 字符
cn,插入模式,<Up>,光标上移一行
cn,文本对象,"a""",双引号字符串
cn,文本对象,a',单引号字符串
cn,文本对象,a(,等同于 ab
cn,文本对象,a),等同于 ab
cn,文本对象,a<,"""一个 <> 块"" 从 '<' 到匹配的 '>'"
cn,文本对象,a>,等同于 a<
cn,文本对象,a[,"""一个 [] 块"" 从 '[' 到匹配的 ']'"
cn,文本对象,a],等同于 a[
cn,文本对象,a`,反引号字符串
cn,文本对象,a{,等同于 aB
cn,文本对象,a},等同于 aB
cn,文本对象,ab,"""一个块"" 从 ""[("" 到 ""])"" (带上括号)"
cn,文本对象,aB,"""一个大块"" 从 ""[{"" 到 ""]}"" (带上括号)"
cn,文本对象,ap,"""一个段落"" (带上空白)"
cn,文本对象,as,"""一个句子"" (带上空白)"
cn,文本对象,at,"""一个标签块"" (带上空白)"
cn,文本对象,aw,"""一个单词"" (带上空白)"
cn,文本对象,aW,"""一个字串"" (带上空白)"
cn,文本对象,"i""",双引号字符串，不带引号
cn,文本对象,i',单引号字符串，不带引号
cn,文本对象,i(,等同于 ib
cn,文本对象,i),等同于 ib
cn,文本对象,i<,"""内含 <> 块"" 从 '<' 到匹配的 '>'"
cn,文本对象,i>,等同于 i<
cn,文本对象,i[,"""内含 [] 块"" 从 '[' 到匹配的 ']'"
cn,文本对象,i],等同于 i[
cn,文本对象,i`,反引号字符串，不带反引号
cn,文本对象,i{,等同于 iB
cn,文本对象,i},等同于 iB
cn,文本对象,ib,"""内含块"" 从 ""[("" 到 ""])"""
cn,文本对象,iB,"""内含大块"" 从 ""[{"" 到 ""]}"""
cn,文本对象,ip,"""内含段落"""
cn,文本对象,is,"""内含句子"""
cn,文本对象,it,"""内含标签块"""
cn,文本对象,iw,"""内含单词"""
cn,文本对象,iW,"""内含字串"""
cn,方括号命令,[#,光标移动到前面第 N 个未匹配的 #if、#else 或者 #ifdef
cn,方括号命令,[',光标移动到前面的小写位置标记，定位在它所在行的第一个非空白字符上
cn,方括号命令,[(,光标移动到前面第 N 个未匹配的 '('
cn,方括号命令,[*,"等同于 ""[/"""
cn,方括号命令,[/,光标移动到前面第 N 个 C 注释的开始处
cn,方括号命令,[[,光标后退 N 个小节
cn,方括号命令,[],光标后退 N 个 SECTION
cn,方括号命令,[`,光标移动到前一个小写位置标记
cn,方括号命令,[{,光标后退 N 个未匹配的 '{'
cn,方括号命令,]#,光标移动到后面第 N 个未匹配的 #endif、#else
cn,方括号命令,]',光标移动到后面的小写位置标记，定位在它所在行的第一个非空白字符上
cn,方括号命令,](,光标移动到后面第 N 个未匹配的 ')'
cn,方括号命令,]*,"等同于 ""]/"""
cn,方括号命令,]/,光标移动到后面第 N 个 C 注释的结尾处
cn,方括号命令,]],光标前进 N 个小节
cn,方括号命令,]`,光标移动到后一个小写位置标记
cn,方括号命令,]{,光标前进 N 个未匹配的 '}'
cn,方括号命令,[c,光标后退 N 个更改开始的地方
cn,方括号命令,]c,光标前进 N 个更改开始的地方
cn,方括号命令,[ CTRL-D,跳转到第一个在当前文件和它包含的头文件里匹配光标所在的单词的 #define，从当前文件的头部开始
cn,方括号命令,] CTRL-D,跳转到第一个在当前文件和它包含的头文件里匹配光标所在的单词的 #define，从光标位置开始
cn,方括号命令,[ CTRL-I,跳转到第一个在当前文件和它包含的头文件里匹配光标所在单词的位置，从当前文件头部开始
cn,方括号命令,] CTRL-I,跳转到第一个在当前文件和它包含的头文件里匹配光标所在单词的位置，从光标位置开始
cn,方括号命令,[d,显示第一个在当前文件和它包含的头文件里匹配光标所在的单词的 #define，从当前文件的头部开始
cn,方括号命令,]d,显示第一个在当前文件和它包含的头文件里匹配光标所在的单词的 #define，从光标位置开始
cn,方括号命令,[D,列出在当前文件和它包含的头文件里匹配光标所在的单词的所有定义，从当前文件的头部开始
cn,方括号命令,]D,列出在当前文件和它包含的头文件里匹配光标所在的单词的所有定义，从光标位置开始
cn,方括号命令,[f,"等同于 ""gf"""
cn,方括号命令,]f,"等同于 ""gf"""
cn,方括号命令,[i,显示第一个在当前文件和它包含的头文件里匹配光标所在单词的位置，从当前文件的头部开始
cn,方括号命令,]i,显示第一个在当前文件和它包含的头文件里匹配光标所在单词的位置，从光标位置开始
cn,方括号命令,[I,列出在当前文件和它包含的头文件里匹配光标所在单词的所有位置，从当前文件的头部开始
cn,方括号命令,]I,列出在当前文件和它包含的头文件里匹配光标所在单词的所有位置，从光标位置开始
cn,方括号命令,[m,光标后退 N 个成员函数的开始
cn,方括号命令,]m,光标前进 N 个成员函数的结尾
cn,方括号命令,[<MiddleMouse>,"等同于 ""[p"""
cn,方括号命令,]<MiddleMouse>,"等同于 ""]p"""
cn,方括号命令,[p,"类似于 ""P""，但调整当前行的缩进"
cn,方括号命令,]p,"类似于 ""p""，但调整当前行的缩进"
cn,方括号命令,[P,"等同于 ""[p"""
cn,方括号命令,]P,"等同于 ""[p"""
cn,方括号命令,[s,移动到前一个拼写错误的单词
cn,方括号命令,]s,移动到后一个拼写错误的单词
cn,方括号命令,[z,移动到打开的折叠的开始
cn,方括号命令,]z,移动到打开的折叠的结尾处
cn,普通模式,#,反向搜索第 N 次出现的光标所在的标识符
cn,普通模式,%,查找本行下一个 (花/方) 括号，并转到其匹配的括号上，或者转到匹配的注释配对上，或者转到匹配的预处理命令上。
cn,普通模式,&,重复上次 :s
cn,普通模式,'',光标移动到最近一次跳转之前所在行的第一个CHAR 上
cn,普通模式,'(,光标移动到当前句子的首部所在行的第一个 CHAR上
cn,普通模式,'),光标移动到当前句子的尾部所在行的第一个 CHAR上
cn,普通模式,'<,光标移动到当前缓冲区高亮区开始/曾经开始的行的第一个 CHAR 上。
cn,普通模式,'>,光标移动到当前缓冲区高亮区结束/曾经结束的行的第一个 CHAR 上。
cn,普通模式,'[,光标移动到当前缓冲区最近操作/放置的文本的首部所在行的第一个 CHAR 上
cn,普通模式,'],光标移动到当前缓冲区最近操作/放置的文本的尾部所在行的第一个 CHAR 上
cn,普通模式,'{,光标移动到当前段落的首部所在行的第一个 CHAR上
cn,普通模式,'},光标移动到当前段落的尾部所在行的第一个 CHAR上
cn,普通模式,(,光标回退 N 个句子
cn,普通模式,),光标前进 N 个句子
cn,普通模式,*,正向搜索第 N 次出现的光标所在的标识符
cn,普通模式,+,等同于 <CR>
cn,普通模式,",",反方向重复最近的 f、t、F 或 T N 次
cn,普通模式,-,光标移动到上方 N 行的第一个 CHAR 上
cn,普通模式,.,重复最近的改变，其计数被 N 取代
cn,普通模式,:,开始进入 Ex 命令
cn,普通模式,;,重复最近的 f、t、F 或 T N 次
cn,普通模式,<<,左移 N 行一个 'shiftwidth'
cn,普通模式,==,"通过 ""indent"" 过滤 N 行"
cn,普通模式,>>,右移 N 行一个 'shiftwidth'
cn,普通模式,@:,"重复上次的 "":"" 命令 N 次"
cn,普通模式,@@,重复上次的 @{a-z} N 次
cn,普通模式,^,光标移动到本行的第一个 CHAR 上
cn,普通模式,_,光标移动到下方第 N - 1 行的第一个 CHAR 上
cn,普通模式,`(,光标移动当前句子的开始处
cn,普通模式,`),光标移动当前句子的结束处
cn,普通模式,`<,光标移动高亮区域的开始处
cn,普通模式,`>,光标移动高亮区域的结束处
cn,普通模式,`[,光标移动最近一次操作/放置的文本的开始处
cn,普通模式,`],光标移动最近一次操作/放置的文本的结束处
cn,普通模式,``,光标移动最近一次跳转的位置
cn,普通模式,`{,光标移动当前段落的开始处
cn,普通模式,`},光标移动当前段落的结束处
cn,普通模式,{,光标反向移动 N 个段落
cn,普通模式,|,光标移到第 N 列
cn,普通模式,},光标正向移动 N 个段落
cn,普通模式,~,'tildeop' 关闭时: 切换光标所在处开始的 N 个字符的大小写，并右移光标 N 个字符
cn,普通模式,$,光标移动到往下第 N 行的行尾之后
cn,普通模式,0,光标移动到本行的第一个字符上
cn,普通模式,"1,2,3,4,5,6,7,8,9",附加于命令前，给出计数
cn,普通模式,a,在光标处附加文本 N 次
cn,普通模式,A,在行尾附加文本 N 次
cn,普通模式,@{a-z},执行 {a-z} 寄存器的内容 N 次
cn,普通模式,"""{a-zA-Z0-9.%#:-""}","指定下次删除、抽出或放置使用的寄存器{a-zA-Z0-9.%#:-""} (大写用于添加)({.%#:} 只能用于放置)"
cn,普通模式,'{a-zA-Z0-9},光标移动到位置标记 {a-zA-Z0-9} 所在行的第一个 CHAR 上
cn,普通模式,`{a-zA-Z0-9},光标移动到位置标记 {a-zA-Z0-9}
cn,普通模式,b,光标反向移动 N 个单词
cn,普通模式,B,光标反向移动 N 个 WORD (字串)
cn,普通模式,<BS>,"等同于 ""h"""
cn,普通模式,<C-End>,"等同于 ""G"""
cn,普通模式,[{char},方括号命令 (见下 |[|)
cn,普通模式,]{char},方括号命令 (见下 |]|)
cn,普通模式,<C-Home>,"等同于 ""gg"""
cn,普通模式,<C-Left>,"等同于 ""b"""
cn,普通模式,<C-LeftMouse>,""":ta"" 到鼠标点击所在的单词上"
cn,普通模式,{count}%,转到文件的百分之 N 的位置上
cn,普通模式,{count}:,开始进入 Ex 命令，给出从当前行开始到下方N-1 行为止的行范围
cn,普通模式,{count}<Del>,删除 {count} 最后的一位数字
cn,普通模式,/<CR>,正向搜索最近一次搜索使用的 {pattern}
cn,普通模式,<CR>,光标移到 N 行下面的第一个 CHAR
cn,普通模式,?<CR>,反向搜索最近一次搜索使用的 {pattern}
cn,普通模式,<C-Right>,"等同于 ""w"""
cn,普通模式,<C-RightMouse>,"等同于 ""CTRL-T"""
cn,普通模式,CTRL-,其它        不用
cn,普通模式,CTRL-],:ta 到光标所在的标识符
cn,普通模式,CTRL-^,"编辑第 N 个轮换文件 (等价于 "":e #N"")"
cn,普通模式,CTRL-A,把 N 加到光标所在/之后的数值上
cn,普通模式,CTRL- a - z,保留作扩展用
cn,普通模式,CTRL-B,反向 (Back) 滚动 N 屏
cn,普通模式,CTRL-C,终止当前的 (搜索) 命令
cn,普通模式,CTRL- CTRL-G,进入 'insertmode' 指定的模式
cn,普通模式,CTRL- CTRL-N,进入普通 (Normal) 模式 (空动作)
cn,普通模式,CTRL-D,向下 (Down) 滚动 N 行 (缺省: 半屏)
cn,普通模式,CTRL-E,向上滚动 N 行 (附加 (Extra) N 行)
cn,普通模式,CTRL-F,向前 (Forward) 滚动 N 屏
cn,普通模式,CTRL-G,显示当前文件名和位置
cn,普通模式,CTRL-H,"等同于 ""h"""
cn,普通模式,CTRL-I,等同于 <Tab>
cn,普通模式,CTRL-J,"等同于 ""j"""
cn,普通模式,CTRL-L,重画屏幕
cn,普通模式,CTRL-M,等同于 <CR>
cn,普通模式,CTRL-N,"等同于 ""j"""
cn,普通模式,CTRL-O,跳转到跳转表里第 N 个较旧的项目
cn,普通模式,CTRL-P,"等同于 ""k"""
cn,普通模式,CTRL-Q,(用于终端控制流)
cn,普通模式,CTRL-R,重做 'u' 撤消的改变
cn,普通模式,CTRL-S,(用于终端控制流)
cn,普通模式,CTRL-T,跳转到标签列表的第 N 个较老的标签 (Tag)
cn,普通模式,CTRL-U,上滚 (Upwards) N 行 (缺省: 半屏)
cn,普通模式,CTRL-V,开始面向列块的可视 (Visual) 模式
cn,普通模式,CTRL-W {char},窗口命令，见 |CTRL-W|
cn,普通模式,CTRL-X,从光标所在/之后的数值上减去 N
cn,普通模式,CTRL-Y,下滚 N 行
cn,普通模式,CTRL-Z,暂停程序 (或者启动新的外壳)
cn,普通模式,do,"等同于 "":diffget"""
cn,普通模式,<Down>,"等同于 ""j"""
cn,普通模式,dp,"等同于 "":diffput"""
cn,普通模式,e,光标正向移动到第 N 个单词的结束处
cn,普通模式,E,光标正向移动到第 N 个 WORD 的结束处
cn,普通模式,<End>,"等同于 ""$"""
cn,普通模式,<F1>,等同于 <Help>
cn,普通模式,f{char},光标右移到第 N 次出现的 {char} 上
cn,普通模式,F{char},光标左移到第 N 次出现的 {char} 上
cn,普通模式,!!{filter},通过 {filter} 命令过滤 N 行
cn,普通模式,G,光标移动到第 N 行，缺省是最后一行
cn,普通模式,g{char},扩展命令，见下 |g|
cn,普通模式,h,光标左移 N 个字符
cn,普通模式,H,光标移动到屏幕顶部开始算的第 N 行
cn,普通模式,<Help>,打开帮助窗口
cn,普通模式,<Home>,"等同于 ""0"""
cn,普通模式,i,在光标前插入文本 N 次
cn,普通模式,I,在本行第一个 CHAR 之前插入文本 N 次
cn,普通模式,<Insert>,"等同于 ""i"""
cn,普通模式,j,光标下移 N 行
cn,普通模式,J,连接 (Join) N 行；缺省为 2
cn,普通模式,k,光标上移 N 行
cn,普通模式,K,查找光标所在的关键字 (Keyword)，使用'keywordprg' 的定义
cn,普通模式,l,光标右移 N 个字符
cn,普通模式,L,光标移动到屏幕底部开始算的第 N 行
cn,普通模式,<Left>,"等同于 ""h"""
cn,普通模式,<LeftMouse>,移动光标到鼠标点击处
cn,普通模式,M,光标移动到屏幕的中间一行
cn,普通模式,m{A-Za-z},在光标位置处设置位置标记 {A-Za-z}
cn,普通模式,<MiddleMouse>,"等同于在鼠标点击处 ""gP"""
cn,普通模式,<{motion},左移 Nmove 文本行一个 'shiftwidth'
cn,普通模式,={motion},"通过 ""indent"" 过滤 Nmove 文本行"
cn,普通模式,>{motion},右移 Nmove 文本行一个 'shiftwidth'
cn,普通模式,~{motion},'tildeop' 打开时: 切换 Nmove 文本的大小写
cn,普通模式,!{motion}{filter}2,通过 {filter} 命令过滤 Nmove 文本
cn,普通模式,n,重复最近的 '/' 或 '?' N 次
cn,普通模式,N,反方向重复最近的 '/' 或 '?' N 次
cn,普通模式,<NL>,"等同于 ""j"""
cn,普通模式,o,在光标下方开始一个新行，并插入文本，重复 N次
cn,普通模式,O,在光标上方开始一个新行，并插入文本，重复 N次
cn,普通模式,<PageDown>,等同于 CTRL-F
cn,普通模式,<PageUp>,等同于 CTRL-B
cn,普通模式,/{pattern}<CR>,正向搜索第 N 次出现的 {pattern}
cn,普通模式,?{pattern}<CR>,反向搜索第 N 次出现的 {pattern}
cn,普通模式,q,(在记录时) 停止记录
cn,普通模式,q/,在命令行窗口里编辑 / 命令行
cn,普通模式,q:,在命令行窗口里编辑 : 命令行
cn,普通模式,q?,在命令行窗口里编辑 ? 命令行
cn,普通模式,Q,"切换到 ""Ex"" 模式"
cn,普通模式,"q{0-9a-zA-Z""}","记录输入的字符到命令寄存器 {0-9a-zA-Z""}(大写用于添加)"
cn,普通模式,R,进入替换模式: 覆盖存在的字符，重复输入文本N-1 次
cn,普通模式,r{char},用 {char} 替换 N 个字符
cn,普通模式,<Right>,"等同于 ""l"""
cn,普通模式,<RightMouse>,开始可视模式，移动光标到鼠标点击处
cn,普通模式,<ScrollWheelDown>,窗口向下滚动三行
cn,普通模式,<ScrollWheelLeft>,窗口向左滚动六列
cn,普通模式,<ScrollWheelRight>,窗口向右滚动六列
cn,普通模式,<ScrollWheelUp>,窗口向上滚动三行
cn,普通模式,<S-Down>,等同于 CTRL-F
cn,普通模式,<S-Left>,"等同于 ""b"""
cn,普通模式,<S-LeftMouse>,"等同于在鼠标点击处 ""*"""
cn,普通模式,<Space>,"等同于 ""l"""
cn,普通模式,<S-Right>,"等同于 ""w"""
cn,普通模式,<S-RightMouse>,"等同于在鼠标点击处 ""#"""
cn,普通模式,<S-ScrollWheelDown>,窗口向下滚动完整一页
cn,普通模式,<S-ScrollWheelLeft>,窗口向左滚动完整一页
cn,普通模式,<S-ScrollWheelRight>,窗口向右滚动完整一页
cn,普通模式,<S-ScrollWheelUp>,窗口向上滚动完整一页
cn,普通模式,<S-Up>,等同于 CTRL-B
cn,普通模式,<Tab>,跳转到跳转表里第 N 个较新的项目
cn,普通模式,t{char},光标移动到右侧第 N 次出现的 {char} 之前
cn,普通模式,T{char},光标移动到左侧第 N 次出现的 {char} 之前
cn,普通模式,u,撤消改变
cn,普通模式,U,撤消一行内所有最近的改变
cn,普通模式,<Undo>,"等同于 ""u"""
cn,普通模式,<Up>,"等同于 ""k"""
cn,普通模式,v,开始面向字符的可视 (Visual) 模式
cn,普通模式,V,进入面向行的可视 (Visual) 模式
cn,普通模式,w,光标前移 N 个单词
cn,普通模式,W,光标前移 N 个 WORD
cn,普通模式,"[""x]C","从光标位置到行尾部分，再加上 N-1 行进行修改[到缓冲区 (译者注: 应为寄存器，下同) x]；等价于 ""c$"""
cn,普通模式,"[""x]cc",删除 N 行 [到缓冲区 (见上) x] 并开始编辑
cn,普通模式,"[""x]c{motion}",删除 Nmove 文本 [到缓冲区 (见上) x] 并开始编辑
cn,普通模式,"[""x]D","删除位置到行尾部分，再加上 N-1 行的字符 [到缓冲区 (见上) x]；等价于 ""d$"""
cn,普通模式,"[""x]dd",删除 N 行 [到缓冲区 (见上) x]]
cn,普通模式,"[""x]<Del>","等同于 ""x"""
cn,普通模式,"[""x]d{motion}",删除 Nmove 文本 [到缓冲区 (见上) x]
cn,普通模式,"[""x]p",在光标后放置文本 [从寄存器 x] N 次
cn,普通模式,"[""x]P",在光标放置文本 [到缓冲区 (见上) x] N 次
cn,普通模式,"[""x]s",(替换) 删除 N 个字符 [到缓冲区 (见上) x] 并开始输入
cn,普通模式,"[""x]S","删除 N 行 [到缓冲区 (见上) x]] 并开始输入；等价于 ""cc"""
cn,普通模式,"[""x]x",删除光标开始的 N 个字符 [到缓冲区 (见上) x]
cn,普通模式,"[""x]X",删除光标前的 N 个字符 [到缓冲区 (见上) x]
cn,普通模式,"[""x]Y","抽出 N 行 [到缓冲区 (见上) x]；等价于 ""yy"""
cn,普通模式,"[""x]y{motion}",抽出 Nmove 文本 [到缓冲区 (见上) x]
cn,普通模式,"[""x]yy",抽出 N 行 [到缓冲区 (见上) x]
cn,普通模式,z{char},'z' 开始的命令，见下 |z|
cn,普通模式,ZQ,无论如何退出当前文件
cn,普通模式,ZZ,如果修改过，保存当前文件，然后退出
cn,窗口命令,CTRL-W +,增加当前窗口高度 N 行
cn,窗口命令,CTRL-W -,减少当前窗口高度 N 行
cn,窗口命令,CTRL-W <,减少当前窗口宽度 N 列
cn,窗口命令,CTRL-W =,使得所有窗口同宽同高
cn,窗口命令,CTRL-W >,增加当前窗口宽度 N 列
cn,窗口命令,CTRL-W ],分割窗口并跳转到光标所在的标签上
cn,窗口命令,CTRL-W ^,分割窗口并编辑轮换文件 N
cn,窗口命令,CTRL-W _,设置当前窗口高度为 N (缺省: 尽量大)
cn,窗口命令,CTRL-W |,设置窗口宽度为 N 列
cn,窗口命令,CTRL-W },在预览窗口里显示光标所在的标签
cn,窗口命令,CTRL-W b,跳转到底部的窗口
cn,窗口命令,CTRL-W c,关闭当前窗口 (类似于 |:close|)
cn,窗口命令,CTRL-W CTRL-],"等同于 ""CTRL-W ]"""
cn,窗口命令,CTRL-W CTRL-^,"等同于 ""CTRL-W ^"""
cn,窗口命令,CTRL-W CTRL-_,"等同于 ""CTRL-W _"""
cn,窗口命令,CTRL-W CTRL-B,"等同于 ""CTRL-W b"""
cn,窗口命令,CTRL-W CTRL-C,"等同于 ""CTRL-W c"""
cn,窗口命令,CTRL-W CTRL-D,"等同于 ""CTRL-W d"""
cn,窗口命令,CTRL-W CTRL-F,"等同于 ""CTRL-W f"""
cn,窗口命令,CTRL-W CTRL-G,"等同于 ""CTRL-W g .."""
cn,窗口命令,CTRL-W CTRL-H,"等同于 ""CTRL-W h"""
cn,窗口命令,CTRL-W CTRL-I,"等同于 ""CTRL-W i"""
cn,窗口命令,CTRL-W CTRL-J,"等同于 ""CTRL-W j"""
cn,窗口命令,CTRL-W CTRL-K,"等同于 ""CTRL-W k"""
cn,窗口命令,CTRL-W CTRL-L,"等同于 ""CTRL-W l"""
cn,窗口命令,CTRL-W CTRL-N,"等同于 ""CTRL-W n"""
cn,窗口命令,CTRL-W CTRL-O,"等同于 ""CTRL-W o"""
cn,窗口命令,CTRL-W CTRL-P,"等同于 ""CTRL-W p"""
cn,窗口命令,CTRL-W CTRL-Q,"等同于 ""CTRL-W q"""
cn,窗口命令,CTRL-W CTRL-R,"等同于 ""CTRL-W r"""
cn,窗口命令,CTRL-W CTRL-S,"等同于 ""CTRL-W s"""
cn,窗口命令,CTRL-W CTRL-T,"等同于 ""CTRL-W t"""
cn,窗口命令,CTRL-W CTRL-V,"等同于 ""CTRL-W v"""
cn,窗口命令,CTRL-W CTRL-W,"等同于 ""CTRL-W w"""
cn,窗口命令,CTRL-W CTRL-X,"等同于 ""CTRL-W x"""
cn,窗口命令,CTRL-W CTRL-Z,"等同于 ""CTRL-W z"""
cn,窗口命令,CTRL-W d,分割窗口并跳转到光标所在的定义上
cn,窗口命令,CTRL-W <Down>,"等同于 ""CTRL-W j"""
cn,窗口命令,CTRL-W f,分割窗口并跳转到光标所在的文件名上
cn,窗口命令,CTRL-W F,分割窗口并编辑光标所在的文件名，然后跳转到文件名后给出的行号上。
cn,窗口命令,CTRL-W g ],分割窗口并在光标所在的标签上执行 |:tselect|
cn,窗口命令,CTRL-W g },在光标所在的标签上执行 |:ptjump|
cn,窗口命令,CTRL-W g CTRL-],分割窗口并在光标所在的标签上执行 |:tjump|
cn,窗口命令,CTRL-W g f,在新的标签页里编辑光标所在的文件名
cn,窗口命令,CTRL-W g F,在新的标签页里编辑光标所在的文件名然后跳转到文件名后给出的行号上。
cn,窗口命令,CTRL-W h,跳转到左面第 N 个的窗口 (在首个窗口上停止)
cn,窗口命令,CTRL-W H,移动当前窗口到最左端
cn,窗口命令,CTRL-W i,分割窗口并跳转到光标所在的标识符的声明上
cn,窗口命令,CTRL-W j,跳转到下面第 N 个的窗口 (在最后窗口上停止)
cn,窗口命令,CTRL-W J,移动当前窗口到最底部
cn,窗口命令,CTRL-W k,跳转到上面第 N 个的窗口 (在首个窗口上停止)
cn,窗口命令,CTRL-W K,移动当前窗口到最顶部
cn,窗口命令,CTRL-W l,跳转到右面第 N 个的窗口 (在最后窗口上停止)
cn,窗口命令,CTRL-W L,移动当前窗口到最右端
cn,窗口命令,CTRL-W <Left>,"等同于 ""CTRL-W h"""
cn,窗口命令,CTRL-W n,打开新窗口，N 行高
cn,窗口命令,CTRL-W o,关闭除了当前窗口以外的所有窗口 (类似于|:only|)
cn,窗口命令,CTRL-W p,转到前面一个 (最近访问的) 窗口
cn,窗口命令,CTRL-W P,跳转到预览窗口
cn,窗口命令,CTRL-W q,退出当前窗口 (类似于 |:quit|)
cn,窗口命令,CTRL-W r,向下旋转窗口 N 次
cn,窗口命令,CTRL-W R,向上旋转窗口 N 次
cn,窗口命令,CTRL-W <Right>,"等同于 ""CTRL-W l"""
cn,窗口命令,CTRL-W s,分割当前窗口为两部分，新的窗口 N 行高
cn,窗口命令,CTRL-W S,"等同于 ""CTRL-W s"""
cn,窗口命令,CTRL-W t,跳转到顶部窗口
cn,窗口命令,CTRL-W T,移动当前窗口到新标签页
cn,窗口命令,CTRL-W <Up>,"等同于 ""CTRL-W k"""
cn,窗口命令,CTRL-W v,垂直分割当前窗口，新的窗口 N 列宽
cn,窗口命令,CTRL-W w,转到后面第 N 个窗口 (回绕)
cn,窗口命令,CTRL-W W,跳转到前面第 N 个窗口 (回绕)
cn,窗口命令,CTRL-W x,交换当前和第 N 个窗口 (缺省: 下一个窗口)
cn,窗口命令,CTRL-W z,关闭预览窗口
